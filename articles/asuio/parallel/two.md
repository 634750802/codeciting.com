
# Java并发机制和底层实现原理
java代码在编译后会编程java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，java中所使用的并发机制依赖于JVM的实现和CPU的指令。

## volatile的应用
在多线程并发编程中volatile和synchronized都扮演者重要的角色，volatile是轻量级的synchronized，它在处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用得当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。
- volatile的定义与实现原理
  - Java语言规范第三版中对volatile的定义如下：Java编程语言允许线程访问共享变量。为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型保证所有线程看到的这个变量的值是一致的。
  - 在X86处理器中，JIT编译器生成的汇编指令中，会产生一个`lock`指令。lock指令有两个作用：
    - 将当前处理器缓存行的数据写回到系统内存。
    - 一个处理器的缓存回写到内存导致其他处理器的缓存无效。
- volatile的使用优化
  - 追加字节优化性能
    ```Java
    private transient final PaddedAtomicReference<QNode> head;
    private transient final PaddedAtomicReference<QNode> tail;

    static final class PaddedAtomicReference <T> extends AtomicReference<T>{
        // 补全到64字节
        Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;￼     
        PaddedAtomicReference(T r) {￼     
            super(r);￼   
        }
    }
    public class AtomicReference <V> implements java.io.Serializable{
        private volatile V value;
      //省略其他代码}
    ```

    对于一些处理器，缓存行是64字节宽，如果队列的头结点和尾节点都不足64字节的话，处理器会将他们都读到同一个高速缓存行中。这样当一个处理器访问头结点的时候，整个缓存行都会被锁定，导致其他处理器不能对尾节点进行访问。而队列的出队列和入队列则需要不停的修改头结点和尾节点。所以在多处理器情况下将会严重影响到队列的入队和出队效率。

    >不能使用追加变量到64字节的情况
    > 1. 缓存行非64字节宽的处理器
    > 2. 共享变量不会被频繁的写

## synchronized的实现原理与应用
java中的每一个对象都可以作为锁。具体的表现形式有三种
  - 对于普通方法，锁是当前的实例对象
  - 对于静态方法，锁是当前类的Class对象
  - 对于同步块方法，锁是synchronized括号里面配置的对象

当一个线程试图访问同步代码块时，它首先必须要得到锁，退出或者抛出异常时必须释放锁。

从JVM规范中可以看到Synchronized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令来实现的，而方法同步是使用另外一种方式来实现的，细节在JVM规范里面没有详细说明。但是，方法的同步同样也可以使用这两个指令来实现。

monitorenter指令是在编译后插入到同步代码块开始的地方，而monitorexit是插入到方法结束处和异常处。

任何对象都有一个Monitor与之相关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorente指令时，将会尝试获取对象所对应的monitor的所有权。即尝试获取对象的锁。

- Java对象头  
synchronized用的锁是存储在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽存储对象头，如果是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，等于32bit。
  - Mark Word： 存储对象的hashCode或锁信息
  - Class Metadata Address： 存储指向对象类型数据的指针
  - Array Length： 数组的长度（如果当前对象是数组的话）
- 锁的升级与对比  
Java Se 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和”轻量锁“，在Java SE 1.6中，级别从低到高一次是： 无锁状态、偏向锁状态、轻量锁状态和重量锁状态，这几个状态会随着竞争情况逐渐升级，但不能降级，意味着偏向锁升级为轻量锁后不能降级成偏向锁。
  - 偏向锁  
    在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引入了偏向锁。
    当一个线程访问同步块并获取锁的时候，会在对象头和栈帧中的锁记录里面存储锁偏向的线程ID，以后该线程在进入和退出同步块的时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示该线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）。如果没有设置，则使用CAS竞争锁；如果设置了。则尝试使用CAS将对象头的偏向锁指向当前线程。

    - 偏向锁的撤销  
      偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头要么重新偏向于其他线程，要么恢复到无锁活着标记对象不适合作为偏向锁，最后唤醒暂停的线程。
    - 关闭偏向锁  
      偏向锁在Java 6和Java 7里是默认启用的，但是他在应用城区启动几秒钟之后才激活。可以使用-XX:BiasedLockingStartupDelay=0来关闭延迟。可以使用-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。
  - 轻量级锁
    - 轻量锁加锁：  
      线程执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为执行锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

    - 轻量级锁解锁  
    轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁

    > 自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，就是被阻塞住，当持有锁的线程释放锁之后会唤醒这个线程，被唤醒的线程就会进行新一轮的夺锁之争。
  - 锁的优缺点对比
    |锁|优点|缺点|适用场景|
    |--|--|--|--|
    |偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级别的差距|如果多线程间存在锁竞争会带来额外的所撤销的消耗|适用于只有一个线程访问同步块的场景|
    |轻量级锁|竞争的线程不会阻塞，提高了程序的相应速度|如果始终得不到锁竞争的线程，使用自旋就会消耗CPU|追求相应时间同步块执行速度非常快|
    |重量级锁|线程竞争不使用自旋，不会消耗CPU|线程阻塞，响应时间缓慢|追求吞吐量，同步块执行时间较长|

## 原子操作的实现原理
原子操作意为“不可被中断的一个或一系列操作”
- 处理器如何时间原子操作
  - 使用总线锁保证原子性  
    如果多个处理器同时对共享变量进行读写操作（i++就是经典的读改写操作），那个共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完共享变量的值可能会和期望的不一致。
    如果有两个处理都对共享变量i=1进行i++操作，可能就会出现最后i=2的结果。原因就是两个处理器同时从各自的缓存中读取变量，分别进行加1操作，然后分别写入系统内存中。如果想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。
    处理器使用总线锁就是解决这个问题的。所谓的总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他的处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

    > 系统内存，就是共享变量所在的地方，CPU要对共享变量进行修改，就要先把变量复制到CPU的缓存中，进行操作后，再写回系统内存。

  - 通过缓存锁定来保证原子性  
    内存区域如果被缓存在处理器的缓存行中，并且Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线声言LOCK #信号，而是修改内部的内存地址，并允许它的缓存一致性来保证操作的原子性，因为缓存一致性会阻止同时修改两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存无效。

    处理器不会使用缓存锁定的两种情况
    - 当操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，处理器总会用总线锁定。
    - 有些处理器不支持缓存锁定。

- Java如何实现原子操作
在Java中可以通过锁和循环CAS的方式来实现原子操作
  - 使用循环CAS实现原子操作
    自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止，以下代码实现了一个基于CAS线程安全的计数器方法safeCount和一个非线程安全的计数器count
    ```java
    public class AtomicTest {

        private AtomicInteger atomicI = new AtomicInteger(0);
        private int i = 0;

        public static void main(String[] args) {
            final AtomicTest cas = new AtomicTest();
            List<Thread> ts = new ArrayList<Thread>(600);
            long start = System.currentTimeMillis();
            for (int j = 0; j < 100; j++) {
                Thread t = new Thread(new Runnable() {
                    public void run() {
                        for (int i = 0; i < 10000; i++) {
                            cas.count();
                            cas.safeCount();
                        }
                      }
                });
                ts.add(t);
            }
            for (Thread t : ts) {
                t.start();
            }  
            //等待所有线程执行完成￼ 
            for (Thread t : ts) {
                try {
                    t.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(cas.i);
            System.out.println(cas.atomicI.get());
            System.out.println(System.currentTimeMillis() - start);
         }
          /**
           *
           使用CAS实现线程安全计数器
           */
         private void safeCount() {
             for (; ; ) {
                 int i = atomicI.get();
                 boolean suc = atomicI.compareAndSet(i, ++i);
                 if (suc) {
                     break;
                 }
             }
         }
          /**       
          非线程安全计数器￼  
          */
         private void count() {
             i++;
         }
     }
    ```
     - CAS实现原子操作的三大问题
       - ABA问题
         因为CAS需要在操作值得时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值是A，变成了B，又变成了A，那么使用CAS进行检查的时候回发现它的值没有发生变化，但是世界上却变化了。ABA问题的解决思路就是使用版本号。
       - 循环时间长开销大
         自旋CAS如果长时间不成功，会给CPU带来极大的执行开销。
         如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。
       - 只能保证一个共享变量的原子操作
         当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。

  - 使用锁机制实现原子操作

    锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是，除了偏向锁，JVM实现锁的方式都用循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出的时候使用循环CAS释放锁。
