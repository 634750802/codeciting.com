## 四种隔离级别
### 未提交读
在该级别中，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际使用。读取未提交的数据，也别称之为脏读。
### 提交读
这是大多数数据库系统的默认的隔离级别。它满足了隔离的简单定义： 一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读，因为同一事务的其它实例在该实例处理期间可能会有新的commit，所以同-select可能返回不同结果
### 可重复读
这是MySQL默认的事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这导致了另一个棘手的问题： 幻读（Phantom Read）。简单来说，幻读指的是用户读取某一个范围的数据时，另一个事务又在该范围内出入了新行，当用户读取该范围内的数据行的时候，会发现有新的幻影行出现。InnoDB引擎通过多版本并发控制机制解决了这个问题。
### 可串行化
这是最高的隔离级别，他通过强制事务排序，使之不可能出现相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时和锁竞争。

- 脏读： 事务A更新了一份数据，更新后，事务B读取了刚刚更新的数据，假设事务A中任务出错，回滚了刚刚事务A更新数据的操作，那么事务B就拿到一份错误数据。（隔离性）
- 不可重复读： 在一个事务的两次查询中数据不一致，这可能是两次查询过程中间插入了事务更新的原有数据。（一致性）
- 幻读： 在一个事务的两次查询中，数据数量不一致，例如一个事务查询了几行数据，而另一个事务却在此时插入了新的几列数据，先前的事务中在接下来的查询中，就会发现有几行数据时先前查询所没有。

## InnoDB存储引擎中的锁
InnoDB实现两种行级锁
- 共享锁  （S Lock）
允许事务读一行数据
- 排他锁  （X Lock）
允许事务删除或更新一行数据

如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁，因为读取并没有改变行r的数据，这种情况称为锁兼容（Lock Compatible）。但如果其他的事务T3想获得行r的排他锁，则必须等待事务T1、T2释放行r上的共享锁，这中情况称为锁不兼容。



## 优化顺序
- 定位语句： 慢日志，show processlist
- explain分析SQL的执行计划
- 通过show profile分析SQL
- 通过trace分析优化器如果选择执行计划


## InnoDB关键特性
### 插入缓存
如果一个表中，辅助索引是无序且非唯一的，插入数据的时候，先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入缓存池中；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行合并。这时通常能将多个插入操合并到一个操作中。

### 两次写
将缓冲池中的页写入到物理磁盘之前，先将数据写入到共享表空间（物理磁盘），然后再将数据存储到表信息所在的物理磁盘。
