# 虚拟机类加载机制
代码编译的结果从本地机器转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。
## 概述  
虚拟机把标书类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。这种策略虽然会另类加载时稍微增加一些性能开销，但是会为Java引用程序提供高度的灵活性，Java里天生支持的动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
## 类加载的时机
类从被加载到虚拟机内存中开始，到卸载出为止，它的生命周期包括： 加载（Loading）
、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）7个阶段。其中验证、准备、解析3个部分统称为连接（Linging）。
加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。
:::tip
上文所说的是按部就班地“开始”，而不是按部就班的“进行”或者“完成”，强调这点是因为这些阶段通常都是相互交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另一个阶段。
:::

- 5种必须初始化的情况
  - 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。
  - 使用java.lang.reflect包的方法对类进行反射操作调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
  - 当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
  - 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类。
  - 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

  以上5中会触发类进行初始化的场景，虚拟机规范中使用了一个很前强烈的限定语：“有且仅有”，这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。下面有3个例子。
  ```Java
  public class SuperClass{
      static {
          System.out.println("SuperClass init!");
      }
      public static int value = 123;
  }

  public class SubClass extends SuperClass{
      static{
          System.out.println("SubClass init!");
      }
  }

  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(SubClass.value);
      }
  }
  ```
  输出结果为： SuperClass init!  
  对于静态字段，只有直接定义这个字段的类才会被初始化，因为通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

  ```Java
  public class SuperClass{
      static {
          System.out.println("SuperClass init!");
      }
      public static int value = 123;
  }

  public class SubClass extends SuperClass{
      static{
          System.out.println("SubClass init!");
      }
  }

  public class NotInitialization{
      public static void main(String[] args){
          SuperClass[] sca = new SuperClass[10];
      }
  }
  ```
  运行结果：  
  没有任何数据的运行结果，此段代码，并没有触发类SubClass的初始化。但是在这段代码里面触发了另外一个名为“[LSuperClass”的类的初始化阶段，这是一个有虚拟机自动生成的、直接继承于java.lang.Object的子类。

  ```Java
  public class ConstClass{
      static{
          System.out.println("ConstClass init!");
      }
      public static final String HELLOWORLD = "hello world!";
  }

  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(ConstClass.HELLOWORLD);
      }
  }
  ```
  运行结果：hello world!  
  上面的代码在运行后，没有输出”ConstClass init!”，这是因为虽然Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段，已经将此常量的值“hello world”存储到NotInitialization类的常量池中，以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都被转化为NotInitialization类对自身常量池的引用。
- 接口初始化  
  当初始化一个类时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。
## 类加载机制

### 加载  
  在加载阶段，虚拟机需要完成以下3件事
  1. 通过一个类的全限定名来获取定义此类的二进制字节流
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

  相对于类加载过程的其他阶段，一个非数组类的加载阶段是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的加载器去控制字节流的获取方式。  
  对于数组类而言，情况就有所不同，数据类本省不通过类加载器创建，它是有Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type）最终要靠类加载器去创建，一个数组类创建过程就遵循以下规则。
  1. 如果数组的组件类型是应用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标注。
  2. 如果数据的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联。
  3. 数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性将默认为public。

  加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，任然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 验证  
  验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。  
  Class语言并不一定是Java源码编译来的，可以使用任何途径产生，甚至包括十六进制编辑器直接编写来产生Class文件。
  - 文件格式验证
  - 元数据验证
  - 字节码验证
  - 符号引用验证
### 准备  
  准备阶段是正式为类变量分配内存并设置初始值的阶段，这些变量所使用的内存都在方法区内进行匹配。
  :::tip
  这个阶段中有两个容易产生混淆的概念。首先，这时候进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，这里所说的初始值”通常情况”下是数据类型的零值，“特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么准备阶段变量value就会被初始化为ConstantValue属性所指的值，如 public static final int value = 123；
  :::

### 解析  
  符号引用： 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。  
  直接引用： 直接引用是直接执行目标的指针、相对偏移量或是一个能间接定位到目标的句柄。  
  对同一符号引用进行多次解析请求是很常见的事情，除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存从而避免解析动作重复。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果第一次解析失败了，那么其他指令对这个符号的解析请求也应该收到相同的异常。对于invokedynamic指令，上面的规则不成立。当朋友某一个前面已经由invokedynamic指令触发解析的符号引用时，并不意味着这个解析结果对于其他invokedynamic指令也同样生效。因为invokedynamic指令的目的本来就是用于动态语言支持。
- 类或接口的解析  
  假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或者接口的直接引用C，那虚拟机完成整个解析过程需要以下3个步骤：
    1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类。在加载过程中，由于元数据验证，字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就宣告失败。
    2. 如果C是一个数组类型，并且数组类型的元素类型是对象，也就是N的描述符会是类似”[Ljava/lang/Integer“的形式，那将会按照第一点的规则加载数据元素类型。如果N的描述符如前面所假设的形式，需要加载的元素就是”java.lang.Integer“，接着由虚拟机生成一个代表此数组维度和元素的数组对象。
    3. 如果上面的步骤没有问题，那么C在虚拟机中实际上已经成为一个有效的类或者接口了，但在解析完成之前，还要进行符号引用验证，确认D是否具备对C的访问全新。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。
- 字段解析  
  要解析一个从未被解析过的字段符号的引用，首先将会对字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析，也就是字段所属接口或者类的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致符号引用解析的失败。如果解析成功，那将这个字段所属的类或接口用C表示。
    1. 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
    2. 否则，如果C实现了接口，将会按照集成关系从下往上递归搜索各个接口和它的父接口，如果接口中找到了包含简单名字和字段描述符都与目标想匹配的字段，则返回这个字段的直接引用，查找结束。
    3. 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中找到了包含简单名字和字段描述符都与目标想匹配的字段，则返回这个字段的直接引用，查找结束。
    4. 否则，查找失败，抛出java.lang.NoSuchFieldError异常。
    5. 如果查找过程中成功返回了引用，将会对这个这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。
    :::tip
    在实际应用中，虚拟机的编译器实现可能会比上述规范要求得更加严格一写，如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或者父类的多个接口中出现，那么编译器可能会拒绝编译。
    :::
- 类方法解析  
  类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C标书这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。
    1. 类方法和接口方法符号引用的常量类型是分开的，如果在类方法表中发现class_index中的C是个接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
    2. 如果通过了第一步，在类C中查找是否有简单名称和描述符与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
    3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有返回这个方法的直接引用，查找结束。
    4. 否则，在类C实现的接口列表及他们的父接口中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是个抽象类，这个查找结束，抛出java.lang.AbstractMethodError异常。
    5. 否则，宣告查找结束，抛出java.lang.NoSuchMethodError异常。
    :::tip
    如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。
    :::
- 接口方法解析  
    类方法解析的第一个步骤与字段解析一样，也需要先解析出类方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，我们依然用C标书这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索。
      1. 与类方法解析不同，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那就直接抛出java.lang.IncompatibleClassChangeError异常。
      2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用看，查找结束。
      3. 否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
      4. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。
    :::tip
    由于接口的所有方法默认都是public的，所以不存在权限问题。
    :::

### 初始化  
类初始化是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可是使用自定义的加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源。或者从另外一个角度来表达：初始化阶段是执行类构造器\<client\>()方法的过程。
- \<client\>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
  ```java
  public class Test{
      static int j = 1;
      static{
          j = 0;
          i = 0;  // 给变量赋值可以正常的编译通过
          System.out.println(j);  // 对于在static语句块之前的访问语句，也可以通过
          System.out.println(i);  // 这句编译器会提示”非法向前引用“
      }
      static int i = 1;
  }
  ```
- \<client\>()方法与类的构造方法（或者说实例构造器\<init\>()方法）不同，它不需要显式的调用父类的构造器，虚拟机会保证子类的\<client\>()方法执行之前，父类的\<client\>()方法已经执行完毕。一次虚拟机中第一个被执行的\<client\>()方法的类肯定是java.lang.Object。
- \<client\>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成\<client\>()方法。
- 接口中不使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成\<client\>()方法。但接口与类不同的是，执行接口的\<client\>()方法不需要先执行父接口的\<client\>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外接口的实现类在初始化也一样不会执行接口的\<client\>()方法。
- 虚拟机保证一个类的\<client\>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始haunt一个类，那么只会有一个线程与执行这个类的\<client\>()方法，其他线程都需要阻塞等待，直到活动线程执行\<client\>()方法完毕。
## 类加载器
- 未完待续
