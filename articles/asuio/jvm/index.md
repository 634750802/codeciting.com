
# Java内存区域与内存溢出异常

## 运行时数据区域
- Java虚拟机在执行java程序的过程中会把它所管理的内存划分为如干个不同区域的数据区域。
+ ***程序计数器***
  - 当前线程所执行的字节码的行号计数器。通过改变计数器的值来选取下一条需要执行的字节码指令。
  - 由于java虚拟机通过线程轮流切换并分配处理器执行时间的方式来实现多线程，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。
  - 如果执行的是Native方法。这个计数器的值则为空。
+ ***java虚拟机栈***
  - 线程私有，与线程生命周期相同。
  - 描述的是java方法执行的内存模型：每个方法在被执行的时候都会同时创建一个`栈帧`，用于存储`局部变量表`、`操作栈`、`动态链接`、`方法出口`等信息。每个方法被调用到执行完成的过程，就是一个栈帧在虚拟机栈从`入栈`到`出栈`的过程。
    - 局部变量表存放了编译器可知的各种基本数据类型、对象引用和returnAddress类型。
    - 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个放在需要在帧中需要分配多大的局部变量空间是完全确定的。
  - 如果线程请求的`栈深度`大于虚拟机所允许的深度，抛出StackOverFlowError；如果虚拟机栈可以动态扩展，当扩展是无法申请到足够的内存时会抛出OOM。
+ ***本地方法栈***
  - 与虚拟机栈发挥的作用是非常相似的，区别是虚拟机栈执行的是为java方法服务，本地方法栈为虚拟机使用到的Native方法服务。
  - 本地方法栈也会抛出StackOverFlowError和OOM。
+ ***Java堆***
  - java堆是被`所有线程`共享的一块区域，在虚拟机启动时创建。此内存区域的唯一目的是存放对象实例。
  - java堆是垃圾收集器管理的主要区域，一次也被称为GC堆(Garbage Collected Heap)。
  - 从内存回收角度来看，由于现在收集器基本上都是采用分代收集算法，因此Java堆还可以细分为：`新生代、永久带`。
  - java堆可以是物理上不连续的内存区域，只要在逻辑上是连续的即可。
+ ****方法区****
  - 与java堆一样，方法区也是被`各个线程`共享的内存区域。
  - 用于存储已被虚拟机加载的`类信息`、`常量`、`静态变量`、`即时编吃·从31译后的代码`等数据。
  - 对于习惯在HotSpot虚拟机上开发和部署的程序员来说，很多人愿意把方法区称为`永久代`。
  - java虚拟机对这个区域的限制非常宽松。除了和Java堆一样不需要连续内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言垃圾收集行为在这个区域很比较少出现。在这个区域回收目标主要是`常量池的回收`和`对类型的卸载`。
+ ***运行时常量池***
  - 方法区的一部分
  - Class文件中除了有类的版本、字段、方法、接口等描述信息外。还有一项就是常量池。
  - 用于存放编译期间生成的各种字面变量和符号引用。这部分内容加载后放到方法区的运行时常量池中。
  - 一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来直接引用也存储在运行时常量池中。
  - 运行期间也可以将新的常量放入池中。
+ ***直接内存***
  - 不是虚拟机运行时数据区域的一部分。
  - 可能会出现OOM
  - 在JDK1.4中新加入了NIO（new Input/Output）类，引入了一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样在一些场景中能显著提高性能，避免了Java堆和Native堆中来回复制数据。
  - 本机直接内存的分配不受到Java堆大小的限制。会收到本机总内存的限制。一般会根据实际内存设置-Xmx等参数信息。   

## 对象访问
+ ***Object obj = new Object()***
  - 这段代码出现在方法体中，`Object obj`会被翻译到`Java栈的本地变量表`中，作为一个reference类型数据出现。而`new Object()`这部分语义将会反映到`java堆`中。形成了一块存储了Object类型所有实例数据值（Instance Data, 对象中各个实例字段的数据）的结构化存储。另外在Java堆中必须包含能查到此`对象类型数据`的地址信息，这些信息存储在`方法区`中。
  - 主流的访问对象的方式有两种：`使用句柄`和`直接指针`。
    - 句柄：Java堆中将会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和对象类型数据各自的具体地址信息。
    - 直接指针： Java堆对象的布局中就必须考虑如何防止访问类型数据相关信息，reference中直接存储的就是对象地址。
  - 比较
    - 使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是很普遍的行文）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
    - 使用直接指针访问的最大好处就是访问速度更快，它节省了一次指针定位时间的开销。
## 实战：OOM异常
+ ***Java堆溢出***
  ```Java
  /**
   - VM args:  -Xms20m -Xmx20m -xx:+HeapDumpOnOutOfMemoryError
   */     
   public class HeapOOM{
       static class OOMObject{
       }
       public static void main(String[] args){
           List<OOMObject> list = new ArrayList<>();
           while(true){
               list.add(new OOMObject());
           }
      }
  }
  ```
  - 要解决这个异常，重点是要确认内存中的对象是否是必要的，也就是分清楚到底是内存泄露还是内存溢出。
  - 如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄露对象是通过怎样的路径与GC roots相关联并导致垃圾收集器无法自动回收它们的。
  - 如果不存在泄露，换句话说就是内存中的对象确实都还必须活着，那就应当检查虚拟机参数(-Xmx与-Xms)，与机器物理内存对比看是否还可以调大，从代码上检查是否存在有些生命周期过长、持有状态过长的情况。
+ ***虚拟机栈和本地方法栈溢出***
  - 由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot类虚拟机来说，-Xoss参数虽然存在，但是是无效的。栈容量只由-Xss参数决定。
  ```Java
  /**
   *VM args: -Xss128k
   */
  public class JavaVMStackSOF{

      private int stackLength = 1;
      public void stackLeak(){
          stackLength++;
          stackLeak();
      }

      public static void main(String[] args){
          JavaVMStackSOF oom = new JavaVMStackSOF();
          try{
              oom.stackLeak();
          } catch(Throwable e){
              System.out.println("stack length:" + oom.stackLength);
              throw e;
          }
      }
  }
  ```
  - 如果是建立多线程导致内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。
+ ***运行时常量池溢出***
  - 如果要向运行时常量池添加内容，最简单的方法就是使用String.intern()这个Native方法。
  - 由于常量池分配在方法区内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区的大小，从而间接控制其中常量池的容量。
  ```Java
  /**
   - VM args: -XX:PermSize=10M -XX:MaxPermSize=10M
   */
   public class RuntimeConstantPoolOOM {

       public static void main(String[] args) {
           List<String> list = new ArrayList();
           int i = 0;
           while (true){
              list.add(String.valueOf(i).intern());
           }
       }
   }
   ```
   - 异常OOM后面的提示信息是： PermGen space。说明运行时常量池属于方法区的一部分。
